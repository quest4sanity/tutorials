create table EMPLOYEES
(
   EMP_ID                         bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   NICKNAME                       varchar(32)                    not null,
   LNAME                          varchar(64)                    not null,
   FNAME                          varchar(64)                    not null,
   MNAME                          varchar(64),
   SKILL_ID                       bigint                         not null,
   EMAIL                          varchar(128),
   STUFF                          clob,
   CONSTRAINT PK_EMPLOYEES PRIMARY KEY (EMP_ID),
   CONSTRAINT AK_EMPLOYEES_NICKNAME UNIQUE (NICKNAME)
   -- key AK_EMPLOYEES_NICKNAME (NICKNAME)
);

comment on table EMPLOYEES is 'Дизайнеры, проектировщики, программисты и т.п., работающие над проектами. ';

INSERT INTO EMPLOYEES
(EMP_ID, NICKNAME, FNAME, LNAME, MNAME, SKILL_ID)
VALUES(1, 'iii', 'Ivan', 'Ivanov', 'Ivanovich', 1);
INSERT INTO EMPLOYEES
(EMP_ID, NICKNAME, FNAME, LNAME, MNAME, SKILL_ID)
VALUES(2, 'ppp', 'Petr', 'Petrov', 'Petrovich', 2);
INSERT INTO EMPLOYEES
(EMP_ID, NICKNAME, FNAME, LNAME, MNAME, SKILL_ID)
VALUES(3, 'sss', 'Semen', 'Semenov', 'Semenovich', 3);
INSERT INTO EMPLOYEES
(EMP_ID, NICKNAME, FNAME, LNAME, MNAME,  SKILL_ID)
VALUES(4, 'vab', 'Vladimir', 'Bogdanov', 'Anatoljevich', 4);

/*==============================================================*/
/* Index: "EMPLOYEE_SKILL_FK"                                            */
/*==============================================================*/
/*
create index EMPLOYEE_SKILL_FK
(
   SKILL_ID
);
*/
create table MODULES
(
   MODULE_ID                      bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   PROJECT_ID                     bigint                         not null,
   CODE                           varchar(32)                    not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   STUFF                          clob,
   CONSTRAINT PK_MODULES PRIMARY KEY (MODULE_ID),
   CONSTRAINT AK_MODULES_CODE UNIQUE (PROJECT_ID, CODE)
   -- key AK_MODULES_CODE (PROJECT_ID, CODE)
);

comment on table MODULES is 'Обычно с крупными проектами работают, разбивая их на части. В данной таблице как раз и хранится информация о таком разбиении. Впоследствии данный список модулей можно использовать при заведении задачи. ';

/*==============================================================*/
/* Index: "PROJECT_MODULE_FK"                                            */
/*==============================================================*/
/*
create index PROJECT_MODULE_FK
(
   PROJECT_ID
);
*/
create table PRIORITIES
(
   PRIORITY_ID                    bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   CODE                           varchar(32)                    not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   CONSTRAINT PK_PRIORITIES PRIMARY KEY (PRIORITY_ID),
   CONSTRAINT AK_PRIORITIES_CODE UNIQUE (CODE)
   -- key AK_PRIORITIES_CODE (CODE)
);

comment on table PRIORITIES is 'Справочник приоритетов задач. 
                        
                        Приоритеты задач определяют, как быстро задача должна быть взята в работу и выполнена. ';

INSERT INTO PRIORITIES
(PRIORITY_ID, CODE, TITLE)
VALUES(1, 'MINOR', 'Minor');
INSERT INTO PRIORITIES
(PRIORITY_ID, CODE, TITLE)
VALUES(2, 'MAJOR', 'Major');
INSERT INTO PRIORITIES
(PRIORITY_ID, CODE, TITLE)
VALUES(3, 'CRITICAL', 'Critical');
INSERT INTO PRIORITIES
(PRIORITY_ID, CODE, TITLE)
VALUES(4, 'BLOCKER', 'Blocker');

create table PROJECTS
(
   PROJECT_ID                     bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   CODE                           varchar(32)                    not null,
   MAJOR_VER                      int                            not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   STATE_ID                       bigint                         not null,
   STUFF                          clob,
   CONSTRAINT PK_PROJECTS PRIMARY KEY (PROJECT_ID),
   CONSTRAINT AK_PROJECT_CODE UNIQUE (CODE, MAJOR_VER)
   -- key AK_PROJECT_CODE (CODE, MAJOR_VER)
);

comment on table PROJECTS is 'Проекты, это генерализованная сущность, имеющая скорее маркетинговогый смысл, чем производственный. Версия является неотъемлемой частью проекта и указывает на самый большой номер версии. 
                        
                        Данная таблица по сути является только шапкой, объеденящей Ревизии в одну группу. ';

/*INSERT INTO PROJECTS
(PROJECT_ID, MANAGER_ID, STATE_ID, TITLE)
VALUES(1, 4, 2, 'data');
INSERT INTO PROJECTS
(PROJECT_ID, MANAGER_ID, STATE_ID, TITLE)
VALUES(2, 4, 2, 'variables');
INSERT INTO PROJECTS
(PROJECT_ID, MANAGER_ID, STATE_ID, TITLE)
VALUES(3, 4, 2, 'jax2db');
INSERT INTO PROJECTS
(PROJECT_ID, MANAGER_ID, STATE_ID, TITLE)
VALUES(4, 4, 2, 'repo');
INSERT INTO PROJECTS
(PROJECT_ID, MANAGER_ID, STATE_ID, TITLE)
VALUES(5, 4, 2, 'dataform');*/

/*==============================================================*/
/* Index: "PROJECT_STATE_FK"                                            */
/*==============================================================*/
/*
create index PROJECT_STATE_FK
(
   STATE_ID
);
*/
create table PROJECT_STATES
(
   STATE_ID                       bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   CODE                           varchar(32)                    not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   CONSTRAINT PK_PROJECT_STATES PRIMARY KEY (STATE_ID),
   CONSTRAINT AK_PROJECT_STATES_CODE UNIQUE (CODE)
   -- key AK_PROJECT_STATES_CODE (CODE)
);

comment on table PROJECT_STATES is 'Справочник состояний проектов.';

INSERT INTO PROJECT_STATES
(STATE_ID, CODE, TITLE)
VALUES(1, 'ASIDE', 'Aside');
INSERT INTO PROJECT_STATES
(STATE_ID, CODE, TITLE)
VALUES(2, 'OPENED', 'Opened');
INSERT INTO PROJECT_STATES
(STATE_ID, CODE, TITLE)
VALUES(3, 'DONE', 'Done');
INSERT INTO PROJECT_STATES
(STATE_ID, CODE, TITLE)
VALUES(4, 'CLOSED', 'Closed');

create table RELEASES
(
   RELEASE_ID                     bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   REV_ID                         bigint                         not null,
   RELEASE_VER                    int                            not null,
   RELEASE_DATE                   date,
   STUFF                          clob,
   CONSTRAINT PK_RELEASES PRIMARY KEY (RELEASE_ID),
   CONSTRAINT AK_REV_RELEASES UNIQUE (REV_ID, RELEASE_VER)
   -- key AK_REV_RELEASES (REV_ID, RELEASE_VER)
);

comment on table RELEASES is 'Таблица содержит информацию обо всех официально выпущенных релизах проекта. В отличии от ревизии при формировании нового релиза в проекте не происходит серьезных технических изменений. В подавляющем большинстве случаев каждый новый релиз просто содержит исправление ошибок. 
                        
                        При подготовке релиза в него включаются все выполненные и не привязанные к другому релизу задачи. На основании этих задач строится список вошедших в релиз изменений. ';

/*==============================================================*/
/* Index: "PROJECT_RELEASE_FK"                                            */
/*==============================================================*/
/*
create index PROJECT_RELEASE_FK
(
   REV_ID
);
*/
create table REVISIONS
(
   REV_ID                         bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   PROJECT_ID                     bigint                         not null,
   MINOR_VER                      int                            not null,
   CODE                           varchar(32),
   STUFF                          clob,
   CONSTRAINT PK_REVISIONS PRIMARY KEY (REV_ID),
   CONSTRAINT AK_PROJECT_REVISIONS UNIQUE (PROJECT_ID, MINOR_VER)
   -- key AK_PROJECT_REVISIONS (PROJECT_ID, MINOR_VER)
);

comment on table REVISIONS is 'Главная таблица проекта. Фактически именно вокруг нее собирается вся информация о задачах. 
                        
                        Работа по проекту всегда разбивается на этапы. Каждый такой этап представляет собой крупную задачу, разрабатываему как единое целое. Окончание этапа всегда указывает на то, что с технической точки зрения проект перешел на другой уровень, хотя с маркетинговой представляет собой все тот же проект. ';

/*==============================================================*/
/* Index: "PROJECT_REVISION_FK"                                            */
/*==============================================================*/
/*
create index PROJECT_REVISION_FK
(
   PROJECT_ID
);
*/
create table REVISION_HIST
(
   REV_ID                         bigint                         not null,
   DAT                            date                           not null,
   DATTO                          date                           not null,
   STATE_ID                       bigint                         not null,
   MANAGER_ID                     bigint                         not null,
   STUFF                          clob,
   CONSTRAINT PK_REVISION_HIST PRIMARY KEY (REV_ID, DAT, DATTO)
);

comment on table REVISION_HIST is 'История изменения ряда полей Ривизий. 
                        
                        Данная таблица используется преимущественно для того, чтобы показать, как работает данный механизм в продакшн системах. ';

/*==============================================================*/
/* Index: "REVISION_HIST_FK"                                            */
/*==============================================================*/
/*
create index REVISION_HIST_FK
(
   REV_ID
);
*//*==============================================================*/
/* Index: "REVISION_STATE_FK"                                            */
/*==============================================================*/
/*
create index REVISION_STATE_FK
(
   STATE_ID
);
*//*==============================================================*/
/* Index: "REVISION_MANAGER_FK"                                            */
/*==============================================================*/
/*
create index REVISION_MANAGER_FK
(
   MANAGER_ID
);
*/
create table REVISION_STATES
(
   STATE_ID                       bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   CODE                           varchar(32)                    not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   CONSTRAINT PK_REVISION_STATES PRIMARY KEY (STATE_ID),
   CONSTRAINT AK_REVISION_STATES_CODE UNIQUE (CODE)
   -- key AK_REVISION_STATES_CODE (CODE)
);

create table SKILLS
(
   SKILL_ID                       bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   CODE                           varchar(32)                    not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   CONSTRAINT PK_SKILLS PRIMARY KEY (SKILL_ID),
   CONSTRAINT AK_SKILLS_CODE UNIQUE (CODE)
   -- key AK_SKILLS_CODE (CODE)
);

comment on table SKILLS is 'Справочник квалификаций программистов. ';

INSERT INTO SKILLS
(SKILL_ID, CODE, TITLE)
VALUES(1, 'NOV', 'Novice');
INSERT INTO SKILLS
(SKILL_ID, CODE, TITLE)
VALUES(2, 'JUN', 'Junior');
INSERT INTO SKILLS
(SKILL_ID, CODE, TITLE)
VALUES(3, 'SEN', 'Senior');
INSERT INTO SKILLS
(SKILL_ID, CODE, TITLE)
VALUES(4, 'LEAD', 'Team leader');

create table TAGS
(
   TAG_ID                         varchar(32)                    not null,
   CONSTRAINT PK_TAGS PRIMARY KEY (TAG_ID)
);

comment on table TAGS is 'В данном справочнике находятся любые теги, по которым впоследсвии можно будет производить поиск. ';

create table TASKS
(
   TASK_ID                        bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   REV_ID                         bigint                         not null,
   MODULE_ID                      bigint,
   DAT                            date                           not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   AUTHOR_ID                      bigint                         not null,
   PARENT_ID                      bigint,
   TYPE_ID                        bigint                         not null,
   PRIORITY_ID                    bigint                         not null,
   DAT_PLAN                       date,
   DAT_FACT                       date,
   RELEASE_ID                     bigint,
   STUFF                          clob,
   CONSTRAINT PK_TASKS PRIMARY KEY (TASK_ID)
);

comment on table TASKS is 'Задачи в рамках проекта. 
                        
                        Задачи могут являться частями других задач. ';

/*==============================================================*/
/* Index: "TASK_PRIORITIE_FK"                                            */
/*==============================================================*/
/*
create index TASK_PRIORITIE_FK
(
   PRIORITY_ID
);
*//*==============================================================*/
/* Index: "PARENT_TASK_FK"                                            */
/*==============================================================*/
/*
create index PARENT_TASK_FK
(
   PARENT_ID
);
*//*==============================================================*/
/* Index: "TASK_REVISION_FK"                                            */
/*==============================================================*/
/*
create index TASK_REVISION_FK
(
   REV_ID
);
*//*==============================================================*/
/* Index: "TASK_AUTHOR_FK"                                            */
/*==============================================================*/
/*
create index TASK_AUTHOR_FK
(
   AUTHOR_ID
);
*//*==============================================================*/
/* Index: "TASK_RELEASE_FK"                                            */
/*==============================================================*/
/*
create index TASK_RELEASE_FK
(
   RELEASE_ID
);
*//*==============================================================*/
/* Index: "TASK_MODULE_FK"                                            */
/*==============================================================*/
/*
create index TASK_MODULE_FK
(
   MODULE_ID
);
*//*==============================================================*/
/* Index: "TASK_TYPE_FK"                                            */
/*==============================================================*/
/*
create index TASK_TYPE_FK
(
   TYPE_ID
);
*/
create table TASKS_HIST
(
   TASK_ID                        bigint                         not null,
   DAT                            date                           not null,
   DATTO                          date                           not null,
   EMP_ID                         bigint                         not null,
   WORK_TIME                      time,
   DESCRIPTION                    varchar(2000),
   STUFF                          clob,
   CONSTRAINT PK_TASKS_HIST PRIMARY KEY (TASK_ID, DAT, DATTO)
);

comment on table TASKS_HIST is 'Распределение задач между разработчиками. Каждый разработчик может распределяться на несколько задач, и над одной задачей может работать несколько разработчиков. ';

/*==============================================================*/
/* Index: "EMPLOYEE_ALLOCATION_FK"                                            */
/*==============================================================*/
/*
create index EMPLOYEE_ALLOCATION_FK
(
   EMP_ID
);
*//*==============================================================*/
/* Index: "TASK_ALLOCATION_FK"                                            */
/*==============================================================*/
/*
create index TASK_ALLOCATION_FK
(
   TASK_ID
);
*/
create table TASK_TAGS
(
   TAG_ID                         varchar(32)                    not null,
   TASK_ID                        bigint                         not null,
   CONSTRAINT PK_TASK_TAGS PRIMARY KEY (TASK_ID, TAG_ID)
);

/*==============================================================*/
/* Index: "TASK_TAG_FK"                                            */
/*==============================================================*/
/*
create index TASK_TAG_FK
(
   TASK_ID
);
*//*==============================================================*/
/* Index: "TAG_TASK_FK"                                            */
/*==============================================================*/
/*
create index TAG_TASK_FK
(
   TAG_ID
);
*/
create table TASK_TYPES
(
   TYPE_ID                        bigint                         not null GENERATED BY DEFAULT AS IDENTITY,
   CODE                           varchar(32)                    not null,
   TITLE                          varchar(128)                   not null,
   DESCRIPTION                    varchar(2000),
   CONSTRAINT PK_TASK_TYPES PRIMARY KEY (TYPE_ID),
   CONSTRAINT AK_TASK_TYPES_CODE UNIQUE (CODE)
   -- key AK_TASK_TYPES_CODE (CODE)
);

comment on table TASK_TYPES is 'Справочник типов задач. 
                        
                        В типы задач могут входить: дизайн, проектирование, разработка, документирование и т.п. ';

alter table EMPLOYEES add constraint FK_EMPLOYEE_SKILL foreign key (SKILL_ID)
      references SKILLS (SKILL_ID) on delete restrict on update restrict;

alter table MODULES add constraint FK_PROJECT_MODULE foreign key (PROJECT_ID)
      references PROJECTS (PROJECT_ID) on delete restrict on update restrict;

alter table PROJECTS add constraint FK_PROJECT_STATE foreign key (STATE_ID)
      references PROJECT_STATES (STATE_ID) on delete restrict on update restrict;

alter table RELEASES add constraint FK_PROJECT_RELEASE foreign key (REV_ID)
      references REVISIONS (REV_ID) on delete restrict on update restrict;

alter table REVISIONS add constraint FK_PROJECT_REVISION foreign key (PROJECT_ID)
      references PROJECTS (PROJECT_ID) on delete restrict on update restrict;

alter table REVISION_HIST add constraint FK_REVISION_HIST foreign key (REV_ID)
      references REVISIONS (REV_ID) on delete restrict on update restrict;

alter table REVISION_HIST add constraint FK_REVISION_MANAGER foreign key (MANAGER_ID)
      references EMPLOYEES (EMP_ID) on delete restrict on update restrict;

alter table REVISION_HIST add constraint FK_REVISION_STATE foreign key (STATE_ID)
      references REVISION_STATES (STATE_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_PARENT_TASK foreign key (PARENT_ID)
      references TASKS (TASK_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_TASK_AUTHOR foreign key (AUTHOR_ID)
      references EMPLOYEES (EMP_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_TASK_MODULE foreign key (MODULE_ID)
      references MODULES (MODULE_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_TASK_PRIORITIE foreign key (PRIORITY_ID)
      references PRIORITIES (PRIORITY_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_TASK_RELEASE foreign key (RELEASE_ID)
      references RELEASES (RELEASE_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_TASK_REVISION foreign key (REV_ID)
      references REVISIONS (REV_ID) on delete restrict on update restrict;

alter table TASKS add constraint FK_TASK_TYPE foreign key (TYPE_ID)
      references TASK_TYPES (TYPE_ID) on delete restrict on update restrict;

alter table TASKS_HIST add constraint FK_EMPLOYEE_ALLOCATION foreign key (EMP_ID)
      references EMPLOYEES (EMP_ID) on delete restrict on update restrict;

alter table TASKS_HIST add constraint FK_TASK_ALLOCATION foreign key (TASK_ID)
      references TASKS (TASK_ID) on delete restrict on update restrict;

alter table TASK_TAGS add constraint FK_TAG_TASK foreign key (TAG_ID)
      references TAGS (TAG_ID) on delete restrict on update restrict;

alter table TASK_TAGS add constraint FK_TASK_TAG foreign key (TASK_ID)
      references TASKS (TASK_ID) on delete restrict on update restrict;

